<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maa鸢/司命 - 勘天刻命</title>
    <!-- Element Plus 的样式 -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/element-plus/2.3.8/index.css"
    />
    <!-- 添加 Element Plus 图标库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/element-plus-icons-vue/2.1.0/index.iife.min.js"></script>
    <style>
      input[type="number"] {
        -webkit-appearance: none;
        -moz-appearance: textfield;
        appearance: textfield;
      }

      input[type="number"]::-webkit-inner-spin-button,
      input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        appearance: none;
        margin: 0;
      }

      .container {
        padding: 20px;
      }

      .el-tag {
        margin-right: 8px;
        margin-bottom: 8px;
      }

      .el-form--inline .el-form-item {
        margin-right: 10px;
      }

      .round-cell {
        position: relative;
      }

      .round-cell .delete-button {
        opacity: 0;
        transition: opacity 0.2s;
      }

      .round-cell:hover .delete-button {
        opacity: 1;
      }

      /* 修改这部分，确保按钮悬停时的样式 */
      .round-cell .delete-button:hover {
        opacity: 1 !important;
        color: var(--el-color-danger) !important;
      }

      /* 添加表格行高样式 */
      .el-table__row {
        height: 54px !important; /* 根据前5行的高度设置你可以调整这个 */
      }

      /* 确保单元格内容垂直居中 */
      .el-table__cell {
        vertical-align: middle !important;
      }

      /* 添加拖拽相关样式 */
      .el-tag.draggable {
        cursor: move;
        user-select: none;
      }

      .el-tag.dragging {
        opacity: 0.5;
        background-color: var(--el-color-primary-light-9);
      }

      .el-tag.drag-over {
        transform: scale(1.05);
        transition: transform 0.2s;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="container">
        <!-- 动作列表 -->
        <el-table :data="tableData" style="width: 100%">
          <!-- 回合列 -->
          <el-table-column
            label="回合"
            width="140"
            align="center"
            header-align="center"
          >
            <template #default="{ row }">
              <div
                class="round-cell"
                style="display: flex; align-items: center; gap: 8px"
              >
                <el-button
                  type="danger"
                  size="small"
                  link
                  @click="deleteRound(row.roundNum)"
                  class="delete-button"
                  style="
                    padding: 4px;
                    --el-button-hover-text-color: var(--el-color-danger);
                  "
                >
                  <el-icon><Delete /></el-icon>
                </el-button>
                <span>第 {{ row.roundNum }} 回合</span>
              </div>
            </template>
          </el-table-column>

          <!-- 作列 -->
          <el-table-column label="动作">
            <template #default="{ row }">
              <div style="display: flex; flex-direction: column; gap: 8px">
                <!-- 第一行动作和控件 -->
                <div
                  style="
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                  "
                >
                  <!-- 动作标签和添加控件 -->
                  <div style="display: flex; align-items: center; flex: 1">
                    <!-- 第一行动作显示 -->
                    <div
                      style="
                        display: flex;
                        align-items: center;
                        flex-wrap: wrap;
                      "
                    >
                      <el-tag
                        v-for="(action, index) in row.actions.slice(0, row.firstLineActions)"
                        :key="index"
                        closable
                        draggable="true"
                        class="draggable"
                        :class="{
                          'dragging': draggedAction === action &&
                          dragSourceRound === row.roundNum &&
                          !dragSourceIsExtended
                        }"
                        @close="removeAction(row.roundNum, index)"
                        @dragstart="handleDragStart($event, row.roundNum, index, action, false)"
                        @dragend="handleDragEnd"
                        @dragover.prevent="handleDragOver($event, row.roundNum, index, false)"
                        @drop="handleDrop($event, row.roundNum, index, false)"
                        style="margin-right: 10px"
                      >
                        {{ action }}
                      </el-tag>
                    </div>

                    <!-- 第一行的添加动作控件，在未展开时显示 -->
                    <el-form
                      v-if="row.firstLineActions < 5 && !row.isExtended"
                      :inline="true"
                      style="
                        margin: 0;
                        display: inline-flex;
                        align-items: center;
                      "
                    >
                      <el-form-item style="margin: 0 10px 0 0">
                        <el-select
                          v-model="selectedPositions[row.roundNum]"
                          placeholder="位置"
                          size="small"
                          style="width: 70px"
                        >
                          <el-option
                            v-for="pos in getAvailablePositions(row.actions.slice(0, row.firstLineActions))"
                            :key="pos"
                            :label="pos"
                            :value="pos"
                          >
                          </el-option>
                        </el-select>
                      </el-form-item>
                      <el-form-item style="margin: 0 10px 0 0">
                        <el-select
                          v-model="selectedActions[row.roundNum]"
                          placeholder="动作"
                          size="small"
                          style="width: 70px"
                        >
                          <el-option label="普攻" value="普"></el-option>
                          <el-option label="上拉" value="上"></el-option>
                          <el-option label="下拉" value="下"></el-option>
                        </el-select>
                      </el-form-item>
                      <el-form-item style="margin: 0">
                        <el-button
                          type="primary"
                          size="small"
                          @click="addAction(row.roundNum, false)"
                        >
                          添加
                        </el-button>
                      </el-form-item>
                    </el-form>
                  </div>

                  <!-- 添加重开按钮和选择 -->
                  <el-form :inline="true" style="margin: 0; margin-left: 10px">
                    <el-form-item style="margin: 0 10px 0 0">
                      <el-select
                        v-model="selectedRestart[row.roundNum]"
                        placeholder="重开类型"
                        size="small"
                        style="width: 120px"
                      >
                        <el-option
                          label="全灭重开"
                          value="全灭重开"
                        ></el-option>
                        <el-option
                          label="点左上角重开（导航未实装）"
                          value="点左上角重开"
                        ></el-option>
                      </el-select>
                    </el-form-item>
                    <el-form-item style="margin: 0">
                      <el-button
                        type="warning"
                        size="small"
                        @click="addRestart(row.roundNum)"
                        :disabled="!selectedRestart[row.roundNum]"
                      >
                        添加重开
                      </el-button>
                    </el-form-item>
                  </el-form>

                  <!-- 附加回合按钮 -->
                  <el-button
                    v-if="!row.isExtended"
                    type="primary"
                    size="small"
                    plain
                    @click="extendRound(row.roundNum)"
                    style="margin-left: 10px"
                  >
                    附加回合
                  </el-button>
                </div>

                <!-- 第二行（扩展行）的动作和控件 -->
                <div
                  v-if="row.isExtended"
                  style="display: flex; align-items: center; margin-left: 20px"
                >
                  <div
                    style="display: flex; align-items: center; flex-wrap: wrap"
                  >
                    <el-tag
                      v-for="(action, index) in row.actions.slice(row.firstLineActions)"
                      :key="index + row.firstLineActions"
                      closable
                      draggable="true"
                      class="draggable"
                      :class="{
                        'dragging': draggedAction === action &&
                        dragSourceRound === row.roundNum &&
                        dragSourceIsExtended
                      }"
                      @close="removeAction(row.roundNum, index + row.firstLineActions)"
                      @dragstart="handleDragStart($event, row.roundNum, index + row.firstLineActions, action, true)"
                      @dragend="handleDragEnd"
                      @dragover.prevent="handleDragOver($event, row.roundNum, index + row.firstLineActions, true)"
                      @drop="handleDrop($event, row.roundNum, index + row.firstLineActions, true)"
                      style="margin-right: 10px"
                    >
                      {{ action }}
                    </el-tag>
                  </div>

                  <!-- 第二行的添加动作控件 -->
                  <el-form
                    v-if="row.actions.length < 9"
                    :inline="true"
                    style="margin: 0; display: inline-flex; align-items: center"
                  >
                    <el-form-item style="margin: 0 10px 0 0">
                      <el-select
                        v-model="selectedPositionsExtended[row.roundNum]"
                        placeholder="位置"
                        size="small"
                        style="width: 70px"
                      >
                        <el-option
                          v-for="pos in getAvailablePositionsExtended(row.actions.slice(row.firstLineActions))"
                          :key="pos"
                          :label="pos"
                          :value="pos"
                        >
                        </el-option>
                      </el-select>
                    </el-form-item>
                    <el-form-item style="margin: 0 10px 0 0">
                      <el-select
                        v-model="selectedActionsExtended[row.roundNum]"
                        placeholder="动作"
                        size="small"
                        style="width: 70px"
                      >
                        <el-option label="普攻" value="普"></el-option>
                        <el-option label="上拉" value="上"></el-option>
                        <el-option label="下拉" value="下"></el-option>
                      </el-select>
                    </el-form-item>
                    <el-form-item style="margin: 0">
                      <el-button
                        type="primary"
                        size="small"
                        @click="addAction(row.roundNum, true)"
                      >
                        添加
                      </el-button>
                    </el-form-item>
                  </el-form>
                </div>
              </div>
            </template>
          </el-table-column>
        </el-table>

        <!-- 底部控制区域 -->
        <div
          style="
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 50px;
          "
        >
          <!-- 第一行：回合控制 -->
          <div style="display: flex; align-items: center; gap: 20px">
            <div style="width: 140px; display: flex; justify-content: center">
              <el-button type="primary" @click="addNewRound"
                >新增回合</el-button
              >
            </div>

            <div style="flex-grow: 1; display: flex; justify-content: center">
              <el-form :inline="true">
                <el-form-item label="起始回合" style="margin-bottom: 0">
                  <el-input-number
                    v-model="loopStart"
                    :min="1"
                    :max="50"
                    size="small"
                  ></el-input-number>
                </el-form-item>
                <el-form-item label="结束回合" style="margin-bottom: 0">
                  <el-input-number
                    v-model="loopEnd"
                    :min="1"
                    :max="50"
                    size="small"
                  ></el-input-number>
                </el-form-item>
                <el-form-item style="margin-bottom: 0">
                  <el-button type="primary" @click="generateLoop"
                    >生成循环</el-button
                  >
                </el-form-item>
              </el-form>
            </div>
          </div>

          <!-- 第二行：导出控制 -->
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
            "
          >
            <el-form :inline="true">
              <!-- 添加关卡类别选择 -->
              <el-form-item style="margin-bottom: 0">
                <el-select
                  v-model="levelType"
                  placeholder="关卡类别"
                  style="width: 100px"
                  size="default"
                >
                  <el-option label="主线" value="主线"></el-option>
                  <el-option label="洞窟" value="洞窟"></el-option>
                  <el-option label="其他" value="其他"></el-option>
                </el-select>
              </el-form-item>

              <!-- 添加关卡名称（识别用）输入框 -->
              <el-form-item style="margin-bottom: 0">
                <el-input
                  v-model="levelRecognitionName"
                  placeholder="关卡序号/名"
                  style="width: 95px"
                  size="default"
                >
                </el-input>
              </el-form-item>

              <!-- 原有的作业标题输入框 -->
              <el-form-item style="margin-bottom: 0">
                <template #label>
                  <span style="font-weight: bold; font-size: 16px"
                    >作业标题：</span
                  >
                </template>
                <el-input
                  v-model="levelName"
                  placeholder="请输入作业名称，如关卡/配队"
                  style="width: 250px"
                  size="default"
                >
                </el-input>
              </el-form-item>
            </el-form>

            <div style="font-size: 12px; color: #909399; margin-top: 4px">
              使用“点左上角重开”时，必填关卡类别和关卡序号（识别关卡入口用）
            </div>

            <div style="display: flex; flex-shrink: 0">
              <el-button
                type="primary"
                @click="importConfig"
                plain
                style="margin-left: 20px"
              >
                <template #icon
                  ><el-icon><Download /></el-icon
                ></template>
                导入作业
              </el-button>

              <el-button
                type="danger"
                @click="clearConfig"
                plain
                style="margin-right: 10px"
              >
                <template #icon
                  ><el-icon><Delete /></el-icon
                ></template>
                清空作业
              </el-button>

              <el-button-group style="white-space: nowrap">
                <el-button
                  type="primary"
                  @click="exportConfig"
                  :loading="exporting"
                  :style="{ width: lastExportPath ? '50%' : 'auto' }"
                >
                  <template #icon
                    ><el-icon><Upload /></el-icon
                  ></template>
                  {{ lastExportPath ? '导出' : '导出作业' }}
                </el-button>
                <el-button
                  type="primary"
                  @click="openOutputFolder"
                  v-if="lastExportPath"
                  plain
                  style="width: 50%"
                >
                  <template #icon
                    ><el-icon><Folder /></el-icon
                  ></template>
                  打开
                </el-button>
              </el-button-group>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 修改脚本加载部分 -->

    <!-- 1. 首先加载 Vue -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>

    <!-- 2. 等 Vue 加载完后再加载其他依赖 -->
    <script>
      // 确保 Vue 已经加载完成
      window.onload = function () {
        // 动态加载 Element Plus
        const elementScript = document.createElement("script");
        elementScript.src =
          "https://cdnjs.cloudflare.com/ajax/libs/element-plus/2.3.8/index.full.min.js";
        elementScript.onload = function () {
          // Element Plus 加完成加载图标
          const iconScript = document.createElement("script");
          iconScript.src =
            "https://cdnjs.cloudflare.com/ajax/libs/element-plus-icons-vue/2.1.0/index.iife.min.js";
          iconScript.onload = function () {
            // 图标加载完成初始化应用
            initApp();
          };
          document.head.appendChild(iconScript);
        };
        document.head.appendChild(elementScript);
      };
    </script>

    <!-- 3. 加载 Axios -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.4.0/axios.min.js"></script>

    <!-- 4. 最后加载应用代码 -->
    <script>
      function initApp() {
        const { createApp, ref, onMounted, computed, watch } = Vue;

        // 根据当前域名判断使用哪个 API 地址
        const API_BASE_URL = "http://127.0.0.1:5000/api"; // 固定使用本地地址

        const app = createApp({
          setup() {
            const allActions = ref({});
            const selectedPositions = ref({});
            const selectedActions = ref({});
            const loopStart = ref(1);
            const loopEnd = ref(1);
            const lastExportPath = Vue.ref(""); // 存储最后一次导出的路径
            const exporting = Vue.ref(false); // 导出状态
            const levelName = ref(localStorage.getItem("levelName") || ""); // 添加关卡名称的响式变量
            const selectedPositionsExtended = ref({});
            const selectedActionsExtended = ref({});
            const selectedRestart = ref({});
            const levelType = ref(localStorage.getItem("levelType") || ""); // 添加关卡类别响应式变量
            const levelRecognitionName = ref(
              localStorage.getItem("levelRecognitionName") || ""
            ); // 添加关卡名称（识别用）响应式变量

            const tableData = computed(() => {
              return Object.keys(allActions.value)
                .map((round) => parseInt(round))
                .filter((round) => round <= 50)
                .sort((a, b) => a - b)
                .map((round) => {
                  const roundStr = round.toString();
                  const actions = Array.isArray(allActions.value[roundStr])
                    ? allActions.value[roundStr]
                    : [];
                  return {
                    roundNum: roundStr,
                    actions: actions,
                    isExtended: allActions.value[roundStr]?.isExtended || false,
                    firstLineActions:
                      allActions.value[roundStr]?.firstLineActions ||
                      actions.length,
                  };
                });
            });

            const saveStateToLocalStorage = (
              roundNum,
              isExtended,
              firstLineActions
            ) => {
              const key = `round_${roundNum}_state`;
              const state = {
                isExtended,
                firstLineActions,
              };
              localStorage.setItem(key, JSON.stringify(state));
            };

            const loadStateFromLocalStorage = (roundNum, actionsLength) => {
              const key = `round_${roundNum}_state`;
              const savedState = localStorage.getItem(key);
              if (savedState) {
                const state = JSON.parse(savedState);
                return state;
              }
              // 默认状态
              return {
                isExtended: actionsLength > 5,
                firstLineActions: actionsLength > 5 ? 4 : actionsLength,
              };
            };

            const loadAllActions = async () => {
              try {
                const response = await axios.get(
                  "http://127.0.0.1:5000/api/actions"
                );
                const actions = response.data;

                // 确保每个回合的动作都是数组
                Object.keys(actions).forEach((roundNum) => {
                  const currentActions = Array.isArray(actions[roundNum])
                    ? [...actions[roundNum]]
                    : [];

                  // 从 localStorage 加载状态
                  const state = loadStateFromLocalStorage(
                    roundNum,
                    currentActions.length
                  );

                  // 重新赋值，保持扩展状态
                  actions[roundNum] = currentActions;
                  actions[roundNum].isExtended = state.isExtended;
                  actions[roundNum].firstLineActions = state.firstLineActions;
                });

                allActions.value = actions;
              } catch (error) {
                console.error("加载动作失败:", error);
              }
            };

            const addAction = async (roundNum, isExtended) => {
              try {
                const position = isExtended
                  ? selectedPositionsExtended.value[roundNum]
                  : selectedPositions.value[roundNum];
                const action = isExtended
                  ? selectedActionsExtended.value[roundNum]
                  : selectedActions.value[roundNum];

                if (!position || !action) {
                  ElementPlus.ElMessage.warning("请选择位置和动作");
                  return;
                }

                const currentActions = Array.isArray(allActions.value[roundNum])
                  ? [...allActions.value[roundNum]]
                  : [];

                // 保持扩展状态
                const isExtendedState =
                  allActions.value[roundNum]?.isExtended || false;

                // 更新 firstLineActions 的计算
                let firstLineActionsCount;
                if (isExtended) {
                  // 如果是在扩展行添加，保持原有的 firstLineActions
                  firstLineActionsCount =
                    allActions.value[roundNum]?.firstLineActions || 4;
                } else {
                  // 如果是在第一行添加，增加 firstLineActions
                  firstLineActionsCount =
                    (allActions.value[roundNum]?.firstLineActions || 0) + 1;
                }

                // 创建新动作数组
                const newAction = [`${position}${action}`];

                if (isExtended) {
                  // 在扩展行添加到末尾
                  currentActions.push(newAction);
                } else {
                  // 在第一行添加到 firstLineActions 的位置
                  currentActions.splice(
                    firstLineActionsCount - 1,
                    0,
                    newAction
                  );
                }

                // 更新动作数组，同时保持扩展状态
                await axios.put(
                  `${API_BASE_URL}/actions/${roundNum}`,
                  currentActions
                );

                allActions.value[roundNum] = currentActions;
                allActions.value[roundNum].isExtended = isExtendedState;
                allActions.value[roundNum].firstLineActions =
                  firstLineActionsCount;

                // 保存状态到 localStorage
                saveStateToLocalStorage(
                  roundNum,
                  isExtendedState,
                  firstLineActionsCount
                );

                // 重置选择
                if (isExtended) {
                  selectedPositionsExtended.value[roundNum] = "";
                  selectedActionsExtended.value[roundNum] = "";
                } else {
                  selectedPositions.value[roundNum] = "";
                  selectedActions.value[roundNum] = "";
                }

                ElementPlus.ElMessage.success("添加动作成功");
              } catch (error) {
                console.error("添加动作失败:", error);
                ElementPlus.ElMessage.error("添加动作失败");
              }
            };

            const removeAction = async (roundNum, index) => {
              const round = allActions.value[roundNum];
              if (!round) return;

              // 判断删除的是第一行还是第二行的动作
              const isFirstLine = index < round.firstLineActions;

              round.splice(index, 1);
              if (isFirstLine) {
                round.firstLineActions--;
                // 保存更新后的状态
                saveStateToLocalStorage(
                  roundNum,
                  round.isExtended,
                  round.firstLineActions
                );
              }

              try {
                await axios.put(
                  `http://127.0.0.1:5000/api/actions/${roundNum}`,
                  round
                );
                ElementPlus.ElMessage.success("删除成功");
              } catch (error) {
                console.error("删除失败:", error);
                ElementPlus.ElMessage.error("删除失败");
              }
            };

            const addNewRound = async () => {
              const rounds = Object.keys(allActions.value).map((r) =>
                parseInt(r)
              );

              // 找到第一个空缺的回合号
              let nextRound = 1;
              while (rounds.includes(nextRound) && nextRound <= 50) {
                nextRound++;
              }

              // 检查是否超过50回合制
              if (nextRound > 50) {
                ElementPlus.ElMessage.warning("已达到50回合上限");
                return;
              }

              allActions.value[nextRound] = [];
              try {
                await axios.post(
                  `http://127.0.0.1:5000/api/actions/add/${nextRound}`
                );
                ElementPlus.ElMessage.success("新增回功");
              } catch (error) {
                console.error("新增回合失败:", error);
                ElementPlus.ElMessage.error("新增回合失败");
              }
            };

            const generateLoop = async () => {
              if (loopStart.value > loopEnd.value) {
                ElementPlus.ElMessage.warning("开始回合不能大于结束回合");
                return;
              }

              // 检查选定范围内的回合是否都有动作
              const hasAllRounds = Array.from(
                { length: loopEnd.value - loopStart.value + 1 },
                (_, i) => (loopStart.value + i).toString()
              ).every((round) => round in allActions.value);

              if (!hasAllRounds) {
                ElementPlus.ElMessage.warning(
                  "选定范围内的某些回合尚未创建，请先创建所有需要的回合"
                );
                return;
              }

              // 计算当前最大回合数
              const maxRound = Math.max(
                ...Object.keys(allActions.value).map(Number)
              );
              const templateLength = loopEnd.value - loopStart.value + 1;

              // 检查是否会超50回合限制
              if (maxRound + templateLength > 50) {
                ElementPlus.ElMessage.warning("添加将超50回合限制");
                return;
              }

              try {
                await axios.post(
                  "http://127.0.0.1:5000/api/actions/generate-loop",
                  {
                    start: loopStart.value,
                    end: loopEnd.value,
                  }
                );
                await loadAllActions();
                ElementPlus.ElMessage.success("生成循环成功");
              } catch (error) {
                console.error("生成循环失败:", error);
                ElementPlus.ElMessage.error(
                  error.response?.data?.error || "生成循环失"
                );
              }
            };

            const deleteRound = async (roundNum) => {
              try {
                const currentActions = allActions.value[roundNum] || [];

                // 如果前回合有动作，先清空动作
                if (currentActions.length > 0) {
                  await axios.put(`${API_BASE_URL}/actions/${roundNum}`, []);
                  allActions.value[roundNum] = [];
                  ElementPlus.ElMessage.success("已清空该回合动作");
                  return;
                }

                // 如果回合已经是空的，则删除整个回合
                await ElementPlus.ElMessageBox.confirm(
                  "确认删除该回合？",
                  "提示",
                  {
                    confirmButtonText: "确定",
                    cancelButtonText: "取消",
                    type: "warning",
                  }
                );

                await axios.delete(`${API_BASE_URL}/rounds/${roundNum}`);
                delete allActions.value[roundNum];
                ElementPlus.ElMessage.success("删除回合成功");
              } catch (error) {
                if (error !== "cancel") {
                  console.error("操作失败:", error);
                  ElementPlus.ElMessage.error("操作失败");
                }
              }
            };

            // 获取可用位置
            const getAvailablePositions = (actions) => {
              const usedPositions = actions.map((actionGroup) =>
                parseInt(actionGroup[0][0])
              );
              return [1, 2, 3, 4, 5].filter(
                (pos) => !usedPositions.includes(pos)
              );
            };

            // 添加的方法用于获取第二行的可用位置
            const getAvailablePositionsExtended = (actions) => {
              const usedPositions = actions.map(
                (actionGroup) => actionGroup[0][0]
              );
              return ["1", "2", "3", "4", "5"].filter(
                (pos) => !usedPositions.includes(pos)
              );
            };

            const exportConfig = async () => {
              try {
                if (!levelName.value.trim()) {
                  ElementPlus.ElMessage.warning("请输入作业标题");
                  return;
                }
                if (!levelType.value) {
                  ElementPlus.ElMessage.warning("请选择关卡类别");
                  return;
                }
                if (!levelRecognitionName.value.trim()) {
                  ElementPlus.ElMessage.warning("请输入关卡名称（识别用）");
                  return;
                }

                exporting.value = true;
                const response = await axios.get(`${API_BASE_URL}/export`, {
                  params: {
                    level_name: levelName.value,
                    level_type: levelType.value,
                    level_recognition_name: levelRecognitionName.value,
                  },
                });

                lastExportPath.value = response.data.path;

                ElementPlus.ElMessage({
                  message: response.data.message,
                  type: "success",
                  duration: 5000,
                });
              } catch (error) {
                console.error("导出失败:", error);
                ElementPlus.ElMessage.error(
                  error.response?.data?.error || "导出失败"
                );
              } finally {
                exporting.value = false;
              }
            };

            const openOutputFolder = async () => {
              try {
                if (!lastExportPath.value) {
                  ElementPlus.ElMessage.warning("请先导出配置文件");
                  return;
                }

                await axios.post(`${API_BASE_URL}/open-folder`, {
                  path: lastExportPath.value,
                });
              } catch (error) {
                console.error("打开件夹失败:", error);
                ElementPlus.ElMessage.error("打开文件夹失败");
              }
            };

            const clearConfig = async () => {
              try {
                await ElementPlus.ElMessageBox.confirm(
                  "确认清空所有动作？此操作不可恢复",
                  "警告",
                  {
                    confirmButtonText: "确定",
                    cancelButtonText: "取消",
                    type: "warning",
                  }
                );

                await axios.post(`${API_BASE_URL}/actions/clear`);
                allActions.value = {};

                // 清除所有回合状态的 localStorage
                for (let i = 1; i <= 50; i++) {
                  localStorage.removeItem(`round_${i}_state`);
                }

                // 清空其他存储的值
                localStorage.removeItem("levelType");
                localStorage.removeItem("levelRecognitionName");
                localStorage.removeItem("levelName");

                // 清空响应式变量
                levelType.value = "";
                levelRecognitionName.value = "";
                levelName.value = "";

                ElementPlus.ElMessage.success("动作已清空");
              } catch (error) {
                if (error !== "cancel") {
                  console.error("清空失败:", error);
                  ElementPlus.ElMessage.error("清空失败");
                }
              }
            };

            const importConfig = async () => {
              try {
                const input = document.createElement("input");
                input.type = "file";
                input.accept = ".json";

                input.onchange = async (event) => {
                  const file = event.target.files[0];
                  if (!file) return;

                  // 设置关卡名称（去掉.json后缀）
                  levelName.value = file.name.replace(".json", "");

                  try {
                    // 创建 FormData 对象
                    const formData = new FormData();
                    formData.append("file", file);

                    const response = await axios.post(
                      `${API_BASE_URL}/actions/import`,
                      formData,
                      {
                        headers: {
                          "Content-Type": "multipart/form-data",
                        },
                      }
                    );

                    // 更新动作配置
                    allActions.value = response.data.actions;

                    // 设置关卡类型和识别名称
                    if (response.data.config_info) {
                      levelType.value = response.data.config_info.level_type;
                      levelRecognitionName.value =
                        response.data.config_info.level_recognition_name;
                    }

                    ElementPlus.ElMessage.success("导入成功");
                  } catch (error) {
                    console.error("导入失败:", error);
                    ElementPlus.ElMessage.error(
                      error.response?.data?.error || "导入失败"
                    );
                  }
                };

                input.click();
              } catch (error) {
                console.error("导入失败:", error);
                ElementPlus.ElMessage.error("导入失败");
              }
            };

            const extendRound = (roundNum) => {
              if (allActions.value[roundNum]) {
                const currentActions = Array.isArray(allActions.value[roundNum])
                  ? [...allActions.value[roundNum]]
                  : [];

                // 保持动作数组的结构，但添加额外的属性
                allActions.value[roundNum] = currentActions;
                // 添加扩展属性
                allActions.value[roundNum].isExtended = true;
                allActions.value[roundNum].firstLineActions =
                  currentActions.length;

                // 重置第二行的选择
                selectedPositionsExtended.value[roundNum] = "";
                selectedActionsExtended.value[roundNum] = "";
              }
            };

            const draggedAction = ref(null);
            const dragSourceRound = ref(null);
            const dragSourceIndex = ref(null);
            const dragSourceIsExtended = ref(false);

            const handleDragStart = (
              event,
              roundNum,
              index,
              action,
              isExtended
            ) => {
              draggedAction.value = action;
              dragSourceRound.value = roundNum;
              dragSourceIndex.value = index;
              dragSourceIsExtended.value = isExtended;
              event.dataTransfer.effectAllowed = "move";
            };

            const handleDragEnd = () => {
              draggedAction.value = null;
              dragSourceRound.value = null;
              dragSourceIndex.value = null;
              dragSourceIsExtended.value = false;
            };

            const handleDragOver = (event, roundNum, index, isExtended) => {
              // 只允许同一回合且同一区域（第一行或附加回合）内的拖拽
              if (
                roundNum === dragSourceRound.value &&
                isExtended === dragSourceIsExtended.value
              ) {
                event.preventDefault();
                event.dataTransfer.dropEffect = "move";
              }
            };

            const handleDrop = async (
              event,
              targetRound,
              targetIndex,
              isExtended
            ) => {
              event.preventDefault();

              // 确保只在同一回合且同一区域内移动
              if (
                draggedAction.value === null ||
                targetRound !== dragSourceRound.value ||
                isExtended !== dragSourceIsExtended.value
              ) {
                return;
              }

              const sourceIndex = dragSourceIndex.value;
              const actions = [...allActions.value[targetRound]];

              // 保存当前的扩展状态和第一行动作数量
              const isExtendedState =
                allActions.value[targetRound]?.isExtended || false;
              const firstLineActionsCount =
                allActions.value[targetRound]?.firstLineActions ||
                actions.length;

              if (!isExtended) {
                // 在第一行内移动
                if (sourceIndex < targetIndex) {
                  // 向右移动
                  const temp = actions[sourceIndex];
                  for (let i = sourceIndex; i < targetIndex; i++) {
                    actions[i] = actions[i + 1];
                  }
                  actions[targetIndex] = temp;
                } else if (sourceIndex > targetIndex) {
                  // 向左移动
                  const temp = actions[sourceIndex];
                  for (let i = sourceIndex; i > targetIndex; i--) {
                    actions[i] = actions[i - 1];
                  }
                  actions[targetIndex] = temp;
                }
              } else {
                // 在扩展行内移动（需要考虑firstLineActionsCount的偏移）
                const actualSourceIndex = sourceIndex;
                const actualTargetIndex = targetIndex;

                if (actualSourceIndex < actualTargetIndex) {
                  const temp = actions[actualSourceIndex];
                  for (let i = actualSourceIndex; i < actualTargetIndex; i++) {
                    actions[i] = actions[i + 1];
                  }
                  actions[actualTargetIndex] = temp;
                } else if (actualSourceIndex > actualTargetIndex) {
                  const temp = actions[actualSourceIndex];
                  for (let i = actualSourceIndex; i > actualTargetIndex; i--) {
                    actions[i] = actions[i - 1];
                  }
                  actions[actualTargetIndex] = temp;
                }
              }

              // 保持原有的扩展状态和第一行动作数量
              actions.isExtended = isExtendedState;
              actions.firstLineActions = firstLineActionsCount;

              try {
                await axios.put(
                  `${API_BASE_URL}/actions/${targetRound}`,
                  actions
                );

                // 更新动作数组时保持扩展状态
                allActions.value[targetRound] = actions;
                allActions.value[targetRound].isExtended = isExtendedState;
                allActions.value[targetRound].firstLineActions =
                  firstLineActionsCount;

                ElementPlus.ElMessage.success("动作顺序已更新");
              } catch (error) {
                console.error("更新失败:", error);
                ElementPlus.ElMessage.error("更新失败");
              }

              handleDragEnd();
            };

            const addRestart = async (roundNum) => {
              try {
                const restartType = selectedRestart.value[roundNum];
                if (!restartType) {
                  ElementPlus.ElMessage.warning("请选择重开类型");
                  return;
                }

                const currentActions = Array.isArray(allActions.value[roundNum])
                  ? [...allActions.value[roundNum]]
                  : [];

                // 获取最后一个动作数组
                if (currentActions.length === 0) {
                  ElementPlus.ElMessage.warning("请先添加动作再设置重开");
                  return;
                }

                // 保持扩展状态和第一行动作数量
                const isExtendedState =
                  allActions.value[roundNum]?.isExtended || false;
                const firstLineActionsCount =
                  allActions.value[roundNum]?.firstLineActions ||
                  currentActions.length;

                const lastAction = currentActions[currentActions.length - 1];
                // 添加重开标记
                lastAction.push(
                  `重:${restartType === "全灭重开" ? "全灭" : "左上角"}`
                );

                await axios.put(
                  `${API_BASE_URL}/actions/${roundNum}`,
                  currentActions
                );

                // 更新动作数组，同时保持扩展状态
                allActions.value[roundNum] = currentActions;
                allActions.value[roundNum].isExtended = isExtendedState;
                allActions.value[roundNum].firstLineActions =
                  firstLineActionsCount;

                // 重置选择
                selectedRestart.value[roundNum] = "";

                ElementPlus.ElMessage.success("添加重开成功");
              } catch (error) {
                console.error("添加重开失败:", error);
                ElementPlus.ElMessage.error("添加重开失败");
              }
            };

            watch(levelType, (newValue) => {
              localStorage.setItem("levelType", newValue);
            });

            watch(levelRecognitionName, (newValue) => {
              localStorage.setItem("levelRecognitionName", newValue);
            });

            watch(levelName, (newValue) => {
              localStorage.setItem("levelName", newValue);
            });

            onMounted(() => {
              loadAllActions();
            });

            return {
              allActions,
              selectedPositions,
              selectedActions,
              loopStart,
              loopEnd,
              tableData,
              addAction,
              removeAction,
              addNewRound,
              generateLoop,
              getAvailablePositions,
              deleteRound,
              exportConfig,
              lastExportPath,
              exporting,
              openOutputFolder,
              Download: ElementPlusIconsVue.Download,
              Folder: ElementPlusIconsVue.Folder,
              clearConfig,
              importConfig,
              Upload: ElementPlusIconsVue.Upload,
              Delete: ElementPlusIconsVue.Delete,
              levelName,
              selectedPositionsExtended,
              selectedActionsExtended,
              extendRound,
              getAvailablePositionsExtended,
              draggedAction,
              dragSourceIsExtended,
              handleDragStart,
              handleDragEnd,
              handleDragOver,
              handleDrop,
              selectedRestart,
              addRestart,
              levelType,
              levelRecognitionName,
            };
          },
        });

        // 注册所有图标
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
          app.component(key, component);
        }

        app.use(ElementPlus);
        app.mount("#app");
      }
    </script>
  </body>
</html>
